-- BlinkIt City Insights Query (Optimized for Large Dataset)
-- This query creates the derived table blinkit_city_insights by processing data in batches

-- Step 1: Create target table structure
CREATE TABLE blinkit_city_insights (
    date TEXT,
    brand_id INTEGER,
    brand TEXT,
    image_url TEXT,
    city_name TEXT,
    sku_id INTEGER,
    sku_name TEXT,
    category_id INTEGER,
    category_name TEXT,
    sub_category_id INTEGER,
    sub_category_name TEXT,
    est_qty_sold REAL,
    est_sales_sp REAL,
    est_sales_mrp REAL,
    listed_ds_count INTEGER,
    ds_count INTEGER,
    wt_osa REAL,
    wt_osa_ls REAL,
    mrp REAL,
    sp REAL,
    discount REAL
);

-- Step 2: Insert data with optimized logic (example for one city batch)
INSERT INTO blinkit_city_insights
SELECT 
    DATE(s.created_at) as date,
    s.brand_id,
    s.brand,
    s.image_url,
    c.city_name,
    s.sku_id,
    s.sku_name,
    bc.l1_category_id as category_id,
    bc.l1_category as category_name,
    bc.l2_category_id as sub_category_id,
    bc.l2_category as sub_category_name,
    -- Simplified est_qty_sold calculation (10% of average inventory as proxy)
    CASE 
        WHEN AVG(s.inventory) > 0 THEN ROUND(AVG(s.inventory) * 0.1, 2)
        ELSE 0.0
    END as est_qty_sold,
    -- Estimated sales based on selling price
    ROUND(AVG(s.inventory) * 0.1 * AVG(s.selling_price), 2) as est_sales_sp,
    -- Estimated sales based on MRP
    ROUND(AVG(s.inventory) * 0.1 * AVG(s.mrp), 2) as est_sales_mrp,
    -- Count of stores where this SKU is listed
    COUNT(DISTINCT s.store_id) as listed_ds_count,
    -- Total count of all stores
    (SELECT COUNT(DISTINCT store_id) FROM all_blinkit_category_scraping_stream) as ds_count,
    -- Weighted on-shelf availability (total stores)
    ROUND(CAST(COUNT(DISTINCT CASE WHEN s.inventory > 0 THEN s.store_id END) AS FLOAT) / 
          (SELECT COUNT(DISTINCT store_id) FROM all_blinkit_category_scraping_stream), 4) as wt_osa,
    -- Weighted on-shelf availability (listed stores only)
    ROUND(CAST(COUNT(DISTINCT CASE WHEN s.inventory > 0 THEN s.store_id END) AS FLOAT) / 
          COUNT(DISTINCT s.store_id), 4) as wt_osa_ls,
    -- Mode of MRP (using average as approximation)
    AVG(s.mrp) as mrp,
    -- Mode of selling price (using average as approximation)
    AVG(s.selling_price) as sp,
    -- Discount calculation
    ROUND((AVG(s.mrp) - AVG(s.selling_price)) / AVG(s.mrp), 4) as discount
FROM all_blinkit_category_scraping_stream s
INNER JOIN blinkit_city_map c ON s.store_id = c.store_id
LEFT JOIN blinkit_categories bc ON s.l2_category_id = bc.l2_category_id
WHERE bc.l1_category_id IS NOT NULL
GROUP BY DATE(s.created_at), s.sku_id, c.city_name
ORDER BY date, city_name, sku_id;

-- Note: For large datasets, this query should be executed in batches by city
-- to avoid memory and performance issues. The Python script handles this batching.
